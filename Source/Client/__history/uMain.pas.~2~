unit uMain;

interface

uses
  SysUtils, Windows, Messages, Variants, Classes,
  Graphics, Controls, Forms, Dialogs, ComCtrls, StdCtrls,
  Grids, ValEdit, ExtCtrls, Menus, ActnList, ToolWin,
  ImgList, Themes, Styles, RichEdit, System.ImageList, System.Actions,
  SyncObjs, SharedTypes, System.JSON, SharedTypes;

type
  TTaskInstance = class
  private
    FTaskCS: TCriticalSection;
  public
    TaskName: string;
    Description: string;
    Params: TStringList;
    Log: TStringList;
    IsRunning: Boolean;
    ModuleHandle: THandle;
    Progress: Integer;
    Number: Integer;
    constructor Create;
    destructor Destroy; override;
  end;

  TTaskThread = class(TThread)
  private
    FTask: TTaskInstance;
    FModuleHandle: THandle;
    FTaskName: string;
    FParamStr: string;
    FSuccess: Boolean;
    FIsCancelled: Boolean;
    procedure DoComplete;
  protected
    procedure Execute; override;
    procedure DoTerminate; override;
  public
    constructor Create(ATask: TTaskInstance; AModuleHandle: THandle; const ATaskName, AParamStr: string);
    property Success: Boolean read FSuccess;
    procedure RequestCancellation;
  end;

  TfrmMain = class(TForm)
    StatusBar: TStatusBar;
    MainMenu: TMainMenu;
    mnuFile: TMenuItem;
    mnuRun: TMenuItem;
    mnuSeparator1: TMenuItem;
    mnuExit: TMenuItem;
    mnuEdit: TMenuItem;
    mnuSaveLog: TMenuItem;
    ImageList: TImageList;
    ParamGrid: TValueListEditor;
    TaskList: TListView;
    ToolBar: TToolBar;
    RunButton: TToolButton;
    CancelButton: TToolButton;
    PanelMain: TPanel;
    Splitter1: TSplitter;
    ToolButton1: TToolButton;
    ToolButton2: TToolButton;
    N1: TMenuItem;
    LogGrid: TStringGrid;
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure RunButtonClick(Sender: TObject);
    procedure CancelButtonClick(Sender: TObject);
    procedure SaveLogButtonClick(Sender: TObject);
    procedure mnuExitClick(Sender: TObject);
    procedure TaskListClick(Sender: TObject);
  private
    FModules: TList;
    FTasks: TStringList;
    FSelectedTask: TTaskInstance;
    FLogFileStream: TextFile;
    FActiveThreads: TList;
    FTaskCS: TCriticalSection;

    procedure LoadModules;
    procedure AddLogLine(Task: TTaskInstance; Line: String);
    procedure ShowTaskLog;
  public

  end;

  function GlobalProgressCallback(Percent: Integer; Status, LogLine: PAnsiChar; UserData: Pointer): Boolean; stdcall;

var
  frmMain: TfrmMain;

implementation

{$R *.dfm}

{
  Callback-обработчик прогресса выполнения задачи.
  Данный метод получает процент выполнения, статус и строку лога от исполняемой задачи.
  Он синхронизирует доступ к форме и обновляет интерфейс в потоке формы.
  Если обнаружится, что задача была отменена, возвращает false, сигнализируя о прекращении выполнения.

  @param Percent Процент выполнения задачи.
  @param Status Текущий статус выполнения.
  @param LogLine Новая строка лога, передаваемая задачей.
  @param UserData Указатель на экземпляр TTaskThread, содержащий дополнительную информацию.
  @return True, если задача должна продолжить выполняться, иначе False.
}
function GlobalProgressCallback(Percent: Integer; Status, LogLine: PAnsiChar; UserData: Pointer): Boolean; stdcall;
var
  TaskThread: TTaskThread;
  Task: TTaskInstance;
  Cancelled: Boolean;
begin
  Result := True;
  Cancelled := False;

  TaskThread := TTaskThread(UserData);
  if Assigned(TaskThread) then
    Cancelled := TaskThread.FIsCancelled;

  Task := TaskThread.FTask;

  TThread.Synchronize(nil,
    procedure
    begin
      if LogLine <> nil then
        frmMain.AddLogLine(Task, LogLine);

      if Status <> nil then
        frmMain.TaskList.Items[Task.Number].SubItems[0] := string(Status);
      frmMain.TaskList.Items[Task.Number].SubItems[1] := IntToStr(Percent) + '%';
    end);

  Result := not Cancelled;
end;

{
  Конструктор формы, инициирует загрузку модулей и подготовку интерфейса.
  Этот метод создаёт списки задач, подгружает доступные модули и настраивает внешний вид окна.
}
procedure TfrmMain.FormCreate(Sender: TObject);
var
  i: Integer;
  TaskDescription: string;
begin
  FActiveThreads := TList.Create;
  FModules := TList.Create;
  FTasks := TStringList.Create;
  FTasks.OwnsObjects := True;

  FTaskCS := TCriticalSection.Create;

  LoadModules;

  StatusBar.Panels[1].Text := Format('Загружено модулей: %d', [FModules.Count]);

  TaskList.Clear;
  for i := 0 to FTasks.Count - 1 do
  begin
    TaskDescription := TTaskInstance(FTasks.Objects[i]).Description;
    with TaskList.Items.Add do
    begin
      Caption := TaskDescription;
      Data := FTasks.Objects[i];

      while SubItems.Count < 2 do
        SubItems.Add('');
    end;
  end;
end;

{
  Метод, завершающий жизненный цикл формы.
  Здесь производится освобождение ресурсов и завершение активных потоков.
}
procedure TfrmMain.FormDestroy(Sender: TObject);
var
  i: Integer;
  Thread: TTaskThread;
begin
  for i := 0 to FActiveThreads.Count - 1 do
  begin
    Thread := TTaskThread(FActiveThreads[i]);
    Thread.RequestCancellation;
  end;

  for i := 0 to FModules.Count - 1 do
    FreeLibrary(THandle(FModules[i]));

  FModules.Free;
  FTasks.Free;

  FTaskCS.Free;
end;

{
  Метод загрузки модулей и добавления их задач в список.
  Используется для автоматического обнаружения подключаемых плагинов и формирования единого списка задач.
}
procedure TfrmMain.LoadModules;
var
  SearchRec: TSearchRec;
  ModulePath: string;
  FullPath: string;
  Module: THandle;
  GetCount: Pointer;
  TaskCount: Integer;
  GetInfo: Pointer;
  TaskInfo: TTaskInfo;
  i, Number: Integer;
  Task: TTaskInstance;
begin
  Number := 0;

  ModulePath := ExtractFilePath(Application.ExeName) + 'plugins\*.dll';

  if FindFirst(ModulePath, faAnyFile, SearchRec) = 0 then
  begin
    repeat
      FullPath := ExtractFilePath(Application.ExeName) + 'plugins\' + SearchRec.Name;
      Module := LoadLibrary(PChar(FullPath));
      if Module <> 0 then
      begin
        FModules.Add(Pointer(Module));

        GetCount := GetProcAddress(Module, 'GetTaskCount');
        if Assigned(GetCount) then
        begin
          TaskCount := TGetTaskCount(GetCount)();

          for i := 0 to TaskCount - 1 do
          begin
            GetInfo := GetProcAddress(Module, 'GetTaskInfo');
            TaskInfo := TGetTaskInfo(GetInfo)(i);

            Task := TTaskInstance.Create;
            Task.TaskName := string(TaskInfo.Name);
            Task.Description := string(TaskInfo.Description);
            Task.Params := TStringList.Create;
            Task.Log := TStringList.Create;
            Task.IsRunning := False;
            Task.ModuleHandle := Module;
            Task.Number := Number;
            inc(Number);

            FTasks.AddObject(Task.TaskName, Task);
          end;
        end;
      end;
    until FindNext(SearchRec) <> 0;
    FindClose(SearchRec.FindHandle);
  end;
end;

{
  Обработчик клика по элементу списка задач.
  Когда пользователь выбирает задачу в списке, этот метод обрабатывает выбор, устанавливает нужные параметры и показывает окно ввода параметров.
}
procedure TfrmMain.TaskListClick(Sender: TObject);
var
  SelectedItem: TListItem;
  Task: TTaskInstance;
  TaskName: string;
  GetParams: Pointer;
  Count: Integer;
  Buffer: TTaskParamArray;
  i: Integer;
begin
  if TaskList.ItemIndex = -1 then Exit;

  SelectedItem := TaskList.Items[TaskList.ItemIndex];
  Task := TTaskInstance(SelectedItem.Data);

  if not Assigned(Task) then Exit;

  FSelectedTask := Task;
  ParamGrid.Strings.Clear;
  FSelectedTask.Params.Clear;

  SetLength(Buffer, 20);
  GetParams := GetProcAddress(FSelectedTask.ModuleHandle, 'GetTaskParams');
  if Assigned(GetParams) and TGetTaskParams(GetParams)(PAnsiChar(AnsiString(Task.TaskName)), PTaskParam(@Buffer[0]), Length(Buffer), Count) then
  begin
    for i := 0 to Count - 1 do
    begin
      FSelectedTask.Params.Add(string(Buffer[i].Name));
      ParamGrid.InsertRow(string(Buffer[i].Caption), string(Buffer[i].DefaultValue), True);
    end;
  end;
  ShowTaskLog;
end;

{
  Конструктор потока задачи.
  Инициализирует основные свойства потока, такие как ссылка на задачу, модуль и параметры задачи.

  @param ATask Инстанс задачи, которую нужно запустить.
  @param AModuleHandle Хендл модуля, содержащего задачу.
  @param ATaskName Имя задачи.
  @param AParamStr Строка параметров задачи.
}
constructor TTaskThread.Create(ATask: TTaskInstance; AModuleHandle: THandle; const ATaskName, AParamStr: string);
begin
  inherited Create(False);
  FreeOnTerminate := True;
  FTask := ATask;
  FModuleHandle := AModuleHandle;
  FTaskName := ATaskName;
  FParamStr := AParamStr;
  FSuccess := False;
  FIsCancelled := False;
end;

{
  Основной метод исполнения задачи.
  Выполняет внешнюю процедуру, используя предоставленную строку параметров и систему обратных вызовов.
}
procedure TTaskThread.Execute;
var
  Execute: TExecuteTask;
  Message: string;
  Cancelled: Boolean;
begin
  Execute := GetProcAddress(FModuleHandle, 'ExecuteTask');
  if not Assigned(Execute) then
  begin
    TThread.Synchronize(nil,
      procedure
      begin
        FTask.Log.Add('Ошибка: функция ExecuteTask не найдена в DLL');
      end
    );
    Exit;
  end;

  FSuccess := Execute(
    PAnsiChar(AnsiString(FTaskName)),
    PAnsiChar(AnsiString(FParamStr)),
    @GlobalProgressCallback,
    Pointer(Self)
  );
end;

{
  Метод завершения выполнения задачи.
  Этот метод добавляет запись в лог, меняет статус задачи и сбрасывает флаги выполнения.
}
procedure TTaskThread.DoComplete;
begin
  TThread.Synchronize(nil,
    procedure
    begin
      if Assigned(frmMain) and Assigned(FTask) then
      begin
        if Success then
        begin
          frmMain.AddLogLine(FTask, 'Задача выполнена успешно.');
          frmMain.TaskList.Items[FTask.Number].SubItems[0] := 'Успешно';
        end
        else
        begin
          if FIsCancelled then
          begin
            frmMain.AddLogLine(FTask, 'Задача прервана пользователем.');
            frmMain.TaskList.Items[FTask.Number].SubItems[0] := 'Прервана';
          end
          else
          begin
            frmMain.AddLogLine(FTask, 'Задача завершилась с ошибкой.');
            frmMain.TaskList.Items[FTask.Number].SubItems[0] := 'Ошибка';
          end;
        end;
        FTask.IsRunning := False;
      end;
    end
  );
end;

{
  Стандартный обработчик завершения потока.
  После завершения потока вызывает дополнительный метод завершения, удаляет ссылку на себя из активного списка потоков.
}
procedure TTaskThread.DoTerminate;
begin
  inherited;
  DoComplete;
  frmMain.FActiveThreads.Remove(self);
end;

{
  Метод запроса отмены задачи.
  Использовать для принудительного прекращения выполнения задачи во время её выполнения.
}
procedure TTaskThread.RequestCancellation;
begin
  FIsCancelled := True;
end;

{
  Обработчик нажатия кнопки запуска задачи.
  Этот метод собирает введённые пользователем параметры, сохраняет их и запускает задачу в отдельном потоке.
}
procedure TfrmMain.RunButtonClick(Sender: TObject);
var
  i: Integer;
  Name, Value: string;
  ParamStr: string;
  TaskThread: TTaskThread;
  JO: TJSONObject;

  {
    Вспомогательная функция для сериализации пары ключ-значение в JSON.
    @param JO JSON-объект.
    @param Name Имя параметра.
    @param Value Значение параметра.
    @return Модифицированный JSON-объект.
  }
  function AddString(var JO: TJSONObject; const Name, Value: string): TJSONObject;
  begin
    JO.AddPair(Name, Value);
    Result := JO;
  end;

begin
  if not Assigned(FSelectedTask) then
  begin
    ShowMessage('Выберите задачу из списка');
    Exit;
  end;

  if FSelectedTask.IsRunning then
  begin
    ShowMessage('Задача уже выполняется');
    Exit;
  end;

  JO := TJSONObject.Create;
  try
    for i := 0 to FSelectedTask.Params.Count - 1 do
    begin
      Name := FSelectedTask.Params[i];
      Value := ParamGrid.Cells[1, i+1];
      AddString(JO, Name, Value);
    end;
    ParamStr := JO.ToJSON;
  finally
    JO.Free;
  end;

  FSelectedTask.IsRunning := True;
  AddLogLine(FSelectedTask, 'Запуск задачи: ' + FSelectedTask.Description);
  TaskList.Items[FSelectedTask.Number].SubItems[0] := 'Выполняется...';

  TaskThread := TTaskThread.Create(FSelectedTask, FSelectedTask.ModuleHandle, FSelectedTask.TaskName, ParamStr);
  FActiveThreads.Add(TaskThread);
end;

{
  Обработчик нажатия кнопки отмены задачи.
  Присваивает задаче флаг отмены и пытается остановить её выполнение.
}
procedure TfrmMain.CancelButtonClick(Sender: TObject);
var
  i: Integer;
  Thread: TTaskThread;
  Found: Boolean;
begin
  if not Assigned(FSelectedTask) then
  begin
    ShowMessage('Задача не выбрана');
    Exit;
  end;

  if not FSelectedTask.IsRunning then
  begin
    ShowMessage('Задача не выполняется');
    Exit;
  end;

  Found := False;
  for i := 0 to FActiveThreads.Count - 1 do
  begin
    Thread := TTaskThread(FActiveThreads[i]);
    if Assigned(Thread) and (Thread.FTask = FSelectedTask) then
    begin
      Found := True;
      Break;
    end;
  end;

  if not Found then
  begin
    ShowMessage('Поток для задачи не найден');
    Exit;
  end;

  if Assigned(Thread) then
  begin
    AddLogLine(FSelectedTask, 'Отправлен запрос на прерывание...');
    TaskList.Items[FSelectedTask.Number].SubItems[0] := 'Прерывание...';
    Thread.RequestCancellation;
  end;
end;

{
  Метод добавления строки в лог задачи.
  Он также автоматически обновляет содержимое сетки с логом, обеспечивая правильное отображение новых записей.

  @param Task Экземпляр задачи, к которой добавляется строка.
  @param Line Текст добавляемой строки.
}
procedure TfrmMain.AddLogLine(Task: TTaskInstance; Line: String);
var
  Row: Integer;
  SelPos: integer;
begin
  Line := Format('%s  %s', [FormatDateTime('yyyy-mm-dd hh:nn:ss.zzz', Now), Line]);
  Task.Log.Add(Line);
  if FSelectedTask = Task then
  begin
    if (LogGrid.RowCount = 1) and (LogGrid.Cells[0, 0] = '') then
    begin
      Row := 0;
    end
    else
    begin
      Row := LogGrid.RowCount;
      LogGrid.RowCount := Row + 1;
    end;
    LogGrid.Cells[0, Row] := Line;
    LogGrid.TopRow := LogGrid.RowCount - LogGrid.VisibleRowCount;
  end;
end;

{
  Метод показа журнала выполнения текущей задачи.
  Эта процедура очищает сетку с логом и заново заполняет её последними записями выбранного экземпляра задачи.
}
procedure TfrmMain.ShowTaskLog;
var
  i: Integer;
  Line: string;
begin
  LogGrid.RowCount := 1;
  LogGrid.Rows[0].Clear;
  for i := 0 to FSelectedTask.Log.Count - 1 do
  begin
    Line := FSelectedTask.Log[i];
    AddLogLine(FSelectedTask, Line);
  end;
end;

{
  Обработчик нажатия кнопки сохранения журнала.
  Предоставляет возможность сохранить лог выполнения задачи в указанный файл.
}
procedure TfrmMain.SaveLogButtonClick(Sender: TObject);
var
  SaveDialog: TSaveDialog;
  SL: TStringList;
begin
  if not Assigned(FSelectedTask) then Exit;

  SaveDialog := TSaveDialog.Create(nil);
  try
    SaveDialog.Filter := 'Лог-файлы (*.log)|*.log';
    SaveDialog.FileName := Format('Task_%s_%s.log', [FSelectedTask.TaskName, FormatDateTime('yyyy-mm-dd_hhnnss', Now)]);
    SaveDialog.InitialDir := ExtractFilePath(Application.ExeName);
    if SaveDialog.Execute then
    begin
      SL := TStringList.Create;
      try
        SL.Add('Лог выполнения: ' + FSelectedTask.TaskName);
        SL.Add('------------------------------');
        SL.AddStrings(FSelectedTask.Log);
        SL.SaveToFile(SaveDialog.FileName, TEncoding.UTF8);
        AddLogLine(FSelectedTask, 'Лог сохранён: ' + SaveDialog.FileName);
      finally
        SL.Free;
      end;
    end;
  finally
    SaveDialog.Free;
  end;
end;

{
  Обработчик выбора пункта меню "Выход".
  Просто закрывает приложение.
}
procedure TfrmMain.mnuExitClick(Sender: TObject);
begin
  Close;
end;

{
  Конструктор экземпляра задачи.
  Создаёт критическую секцию для защиты общих данных и готовит остальные поля задачи.
}
constructor TTaskInstance.Create;
begin
  inherited Create;
  FTaskCS := TCriticalSection.Create;
  Params := TStringList.Create;
  Log := TStringList.Create;
  IsRunning := False;
  Progress := 0;
end;

{
  Деструктор экземпляра задачи.
  Освобождает ресурсы и уничтожает критическую секцию.
}
destructor TTaskInstance.Destroy;
begin
  FTaskCS.Free;
  Params.Free;
  Log.Free;
  inherited Destroy;
end;

end.
