library ShellExecute;

uses
  Windows, SysUtils, Classes, ShellAPI, System.JSON,
  SharedTypes in '..\..\SharedTypes.pas';


{$R *.res}

  var
    FProcessHandle: THandle;
    FReadPipe: THandle;
    FTerminated: Boolean;

{
  Получает значение указанного поля из JSON-данных.
  @param JSON Строка JSON
  @param FieldName Имя извлекаемого поля
  @return Значение поля или пустая строка, если оно отсутствует
}
function GetJSONValue(const JSON, FieldName: string): string;
var
  JO: TJSONObject;
  JValue: TJSONValue;
begin
  Result := '';

  JO := TJSONObject.ParseJSONValue(JSON) as TJSONObject;
  if not Assigned(JO) then Exit;

  try
    JValue := JO.GetValue(FieldName);
    if not Assigned(JValue) then
      Exit;

    if JValue is TJSONString then
      Result := TJSONString(JValue).Value
    else if JValue is TJSONNumber then
      Result := TJSONNumber(JValue).Value
    else if JValue is TJSONTrue then
      Result := 'true'
    else if JValue is TJSONFalse then
      Result := 'false'
    else if JValue is TJSONNull then
      Result := 'null'
    else
      Result := JValue.ToString;

  finally
    JO.Free;
  end;
end;


{
  Возвращает количество поддерживаемых задач в библиотеке.
  @return Целочисленное значение, равное количеству реализованных задач
}
function GetTaskCount: Integer; stdcall;
begin
  Result := 1;
end;

{
  Возвращает описание задачи по указанному индексу.
  @param Index Индикатор задачи
  @return Структура с информацией о задаче
}
function GetTaskInfo(Index: Integer): TTaskInfo; stdcall;
var
  Info: TTaskInfo;
begin
  FillChar(Info, SizeOf(Info), 0);
  case Index of
    0:
      begin
        StrPCopy(Info.Name, 'ShellExecute');
        StrPCopy(Info.Description, 'Выполнение Shell-команды');
      end;
  else
    // Неверный индекс — возвращаем пустое имя
    StrPCopy(Info.Name, '');
  end;

  Result := Info;
end;

{
  Возвращает набор параметров для указанной задачи.
  @param TaskName Имя задачи
  @param Buffer Указатель на область хранения параметров
  @param BufferSize Максимальный размер области хранения
  @param Count Выходной параметр - количество полученных параметров
  @return True, если параметры были успешно получены
}
function GetTaskParams(TaskName: PAnsiChar; Buffer: PTaskParam; BufferSize: Integer; out Count: Integer): Boolean; stdcall;
var
  Params: array[0..1] of TTaskParam;
begin
  Result := False;
  FillChar(Params, SizeOf(Params), 0);

  if (TaskName = nil) or (StrLen(TaskName) = 0) then
    Exit;

  if StrIComp(TaskName, 'ShellExecute') = 0 then
  begin
    // Параметры: маски и путь
    StrPCopy(Params[0].Name, 'Command');
    StrPCopy(Params[0].Caption, 'Команда');
    StrPCopy(Params[0].DefaultValue, '7z a backup.zip Data\*.txt');

    StrPCopy(Params[1].Name, 'WorkingDir');
    StrPCopy(Params[1].Caption, 'Рабочая папка');
    StrPCopy(Params[1].DefaultValue, 'C:\Temp');

    Count := 2;
    Result := True;
  end;

  Move(Params[0], Buffer^, Count * SizeOf(TTaskParam));
end;

function ReadOutputThread(ProgressCallback: TProgressCallback; UserData: Pointer): Boolean;
var
  Buffer: array[0..4095] of AnsiChar;
  BytesRead: DWORD;
  LineBuffer: string;
  Lines: TStringList;
  i: Integer;
  Status: String;
  LogLine: String;
begin
  LineBuffer := '';
  Result := False;

  repeat
    // Читаем данные из трубы
    FillChar(Buffer, SizeOf(Buffer), 0);
    if ReadFile(FReadPipe, Buffer, SizeOf(Buffer) - 1, BytesRead, nil) and (BytesRead > 0) then
    begin
      Buffer[BytesRead] := #0;
      LineBuffer := LineBuffer + string(AnsiString(Buffer));

      // Разбиваем на строки
      Lines := TStringList.Create;
      try
        Lines.Text := LineBuffer;

        // Сохраняем последнюю (неполную) строку
        if (Lines.Count > 0) then
          LineBuffer := Lines[Lines.Count - 1]
        else
          LineBuffer := '';

        // Удаляем последнюю строку из обработки
        if Lines.Count > 0 then
          Lines.Delete(Lines.Count - 1);

        // Отправляем каждую готовую строку
        for i := 0 to Lines.Count - 1 do
        begin
          if Trim(Lines[i]) <> '' then
          begin
            if Assigned(ProgressCallback) then
              ProgressCallback(50, PAnsiChar(AnsiString('Выполняется...')), PAnsiChar(AnsiString(Lines[i])), UserData);
          end;
        end;
      finally
        Lines.Free;
      end;
    end;

    // Проверяем, завершился ли процесс
    if (FProcessHandle <> 0) and (WaitForSingleObject(FProcessHandle, 10) <> WAIT_TIMEOUT) then
    begin
      if Assigned(ProgressCallback) then
      begin
        if FTerminated then
          ProgressCallback(50, PAnsiChar(AnsiString('Прервана')), PAnsiChar(AnsiString('Процесс остановлен')), UserData)
        else
        begin
          ProgressCallback(100, PAnsiChar(AnsiString('Успешно')), PAnsiChar(AnsiString('Выполнение завершено')), UserData);
          Result := true;
        end;
      end;

      // Освобождаем ресурсы
      CloseHandle(FProcessHandle);
      FProcessHandle := 0;
      CloseHandle(FReadPipe);
      FReadPipe := 0;
    end;

  until FTerminated or (FProcessHandle = 0);

end;

function Task_ShellExecute(Params: String; ProgressCallback: TProgressCallback; UserData: Pointer): Boolean;
var
  StartupInfo: TStartupInfo;
  ProcessInfo: TProcessInformation;
  SecurityAttr: TSecurityAttributes;
  WritePipe: THandle;
  Cmd: string;
  Command: AnsiString;
  WorkDir: AnsiString;
  WorkingDir: PChar;
  Status: String;
  LogLine: String;
begin
  Result := False;
  FTerminated := False;

  // Проверка: уже запущен?
  if FProcessHandle <> 0 then
    Exit;

  Command := AnsiString(GetJSONValue(Params, 'Command'));
  WorkDir := AnsiString(GetJSONValue(Params, 'WorkingDir'));

  // --- Настройка безопасности для трубы ---
  FillChar(SecurityAttr, SizeOf(SecurityAttr), 0);
  SecurityAttr.nLength := SizeOf(SecurityAttr);
  SecurityAttr.bInheritHandle := True;
  SecurityAttr.lpSecurityDescriptor := nil;

  // --- Создание трубы для перехвата stdout/stderr ---
  if not CreatePipe(FReadPipe, WritePipe, @SecurityAttr, 0) then
    Exit;

  // --- Настройка структуры запуска ---
  FillChar(StartupInfo, SizeOf(StartupInfo), 0);
  StartupInfo.cb := SizeOf(StartupInfo);
  StartupInfo.hStdOutput := WritePipe;
  StartupInfo.hStdError := WritePipe;
  StartupInfo.dwFlags := STARTF_USESTDHANDLES or STARTF_USESHOWWINDOW;
  StartupInfo.wShowWindow := SW_HIDE;

  // --- Определяем рабочую папку ---
  WorkDir := string(WorkingDir);
  if (WorkDir = '') or not DirectoryExists(WorkDir) then
  begin
    WorkDir := ExtractFileDir(string(Command));
    if WorkDir = '' then
      WorkDir := GetCurrentDir;
  end;

  // --- Формируем команду ---
  Cmd := Format('cmd.exe /c "%s"', [string(Command)]);

  // --- Запускаем процесс ---
  if not CreateProcess(
    nil,
    PChar(Cmd),
    nil,
    nil,
    True,
    0,
    nil,
    PChar(WorkDir),
    StartupInfo,
    ProcessInfo
  ) then
  begin
    CloseHandle(FReadPipe);
    CloseHandle(WritePipe);
    Exit;
  end;

  // Сохраняем дескриптор
  FProcessHandle := ProcessInfo.hProcess;
  CloseHandle(WritePipe); // Пишущий конец больше не нужен

  // Уведомляем о старте
  Status := 'Запуск';
  LogLine := 'Запуск: ' + string(Command);
  if Assigned(ProgressCallback) then
    ProgressCallback(50, PAnsiChar(AnsiString(Status)), PAnsiChar(AnsiString(LogLine)), UserData);

  Result := ReadOutputThread(ProgressCallBack, UserData);
end;

{
  Выполняет нужную задачу .
  @param TaskName Имя нужной задачи
  @param Params Строка с параметрами задания
  @param ProgressCallback Коллбэк-функция для передачи хода выполнения
  @param UserData Дополнительные данные для коллбэка
  @return True, если задача была успешно выполнена
}
function ExecuteTask(TaskName: PAnsiChar; Params: PAnsiChar; ProgressCallback: TProgressCallback; UserData: Pointer): Boolean; stdcall;
var
  Task: string;
begin
  Result := False;
  if (TaskName = nil) or (StrLen(TaskName) = 0) then
    Exit;
  if (Params = nil) or not Assigned(ProgressCallback) then
    Exit;
  Task := string(TaskName);
  if  TaskName = 'ShellExecute' then
    Result := Task_ShellExecute(string(Params), ProgressCallback, UserData);
end;

procedure CancelTask; stdcall;
begin
  if FProcessHandle <> 0 then
  begin
    FTerminated := True;
    TerminateProcess(FProcessHandle, 1);
  end;
end;

exports
  GetTaskCount,
  GetTaskInfo,
  GetTaskParams,
  ExecuteTask,
  CancelTask;

begin
  FProcessHandle := 0;
  FReadPipe := 0;
  FTerminated := False;
end.
